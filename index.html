<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Reaktionstest</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  :root{
    --bg:#0f1115;--card:#151923;--muted:#9aa3b2;--text:#e8ecf1;--border:#272e3b;
    --brand:#4f83ff;--brand-600:#2f6bff;--green:#29c76f;--green-700:#1e9c56;
    --red:#ff4d4f;--red-700:#d83a3c;--radius:16px;
    --shadow:0 8px 24px rgba(0,0,0,.25);--shadow-soft:0 6px 16px rgba(0,0,0,.18);
    --space-1:.5rem;--space-2:.75rem;--space-3:1rem;--space-4:1.25rem;--space-5:1.75rem;
    --fs-1:clamp(14px,3.2vw,16px);--fs-2:clamp(16px,4vw,18px);--fs-3:clamp(18px,5vw,22px);--fs-4:clamp(20px,6vw,26px);
  }
  body{margin:0;font-family:ui-sans-serif,system-ui;line-height:1.45;color:var(--text);
    background:radial-gradient(1200px 800px at 50% -10%,rgba(79,131,255,.18),transparent 60%),var(--bg);}
  .container{max-width:780px;margin:0 auto;padding:var(--space-5) var(--space-3);}
  h1{font-size:var(--fs-4);margin:0 0 var(--space-2);}p.lead{color:var(--muted);margin:0 0 var(--space-4);}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);
    box-shadow:var(--shadow);padding:var(--space-4);margin-bottom:var(--space-5);}
  .btn{appearance:none;border:0;cursor:pointer;border-radius:14px;padding:16px 20px;
    min-height:56px;font-weight:700;font-size:var(--fs-2);color:#fff;box-shadow:var(--shadow-soft);}
  #session-ctrl{background:linear-gradient(180deg,var(--brand),var(--brand-600));}
  #download-pdf{background:transparent;color:var(--text);border:1px solid var(--border);}
  #reaction-button{width:100%;min-height:140px;font-size:var(--fs-3);border-radius:18px;color:#fff;box-shadow:var(--shadow);}
  #reaction-button.red{background:linear-gradient(180deg,var(--red),var(--red-700));}
  #reaction-button.green{background:linear-gradient(180deg,var(--green),var(--green-700));}
  .progress-wrap{width:100%;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:999px;
    overflow:hidden;height:14px;margin-top:var(--space-3);margin-bottom:var(--space-3);}
  .progress-bar{height:100%;width:0%;background:linear-gradient(90deg,var(--brand),var(--green));transition:width .25s ease;}
  #history{list-style:none;padding:0;margin:0;display:grid;gap:10px;}
  #history li{padding:12px 14px;border:1px solid var(--border);border-radius:12px;background:rgba(255,255,255,.03);
    display:flex;justify-content:space-between;align-items:center;font-size:var(--fs-1);}
  #history li.early{color:var(--red);border-color:rgba(255,77,79,.35);background:rgba(255,77,79,.06);}
  table{width:100%;border-collapse:collapse;border:1px solid var(--border);border-radius:12px;background:var(--card);}
  th,td{padding:12px;text-align:center;font-size:var(--fs-1);border-bottom:1px solid var(--border);}
  tbody tr:last-child td{border-bottom:0;}
  .subtle{color:var(--muted);font-size:var(--fs-1);}
</style>
</head>
<body>
<div class="container">
  <header class="stack">
    <h1>Reaktionstest</h1>
    <p class="lead">Klicke den Button, sobald er grün wird. 10 gültige Messungen pro Test.</p>
  </header>

  <section class="card stack">
    <div class="actions">
      <button id="session-ctrl" class="btn">Test starten</button>
      <button id="download-pdf" class="btn" style="display:none">Als PDF speichern</button>
    </div>
    <div class="progress-wrap"><div id="progress" class="progress-bar"></div></div>
    <button id="reaction-button" class="red" style="display:none">Warten…</button>
    <p id="result" class="subtle"></p>
  </section>

  <section class="card">
    <h2 style="margin-top:0;">Letzte 10 Tests</h2>
    <ul id="history"></ul>
  </section>

  <section id="daily-section" class="card" style="display:none;">
    <h2 style="margin-top:0;">Tagesübersicht</h2>
    <table id="daily-table">
      <thead><tr><th>Datum</th><th>Beste Reaktionszeit (ms)</th><th>Ø letzte 10 (ms)</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>
</div>

<video id="frontcam" autoplay playsinline muted style="width:0;height:0;opacity:0;position:absolute;left:-9999px;"></video>
<canvas id="shot" width="0" height="0" style="display:none;"></canvas>

<script>
(() => {
  // --- Mess-Offset fest im Code (nicht sichtbar) ---
  const DEFAULT_OFFSET_MS = 120; // hier ggf. anpassen
  const getOffset = () => DEFAULT_OFFSET_MS;

  const vibrateShort = () => { if (navigator.vibrate) navigator.vibrate([15]); };
  const pad2 = n => String(n).padStart(2,'0');
  const ymd = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

  // DOM
  const btn = document.getElementById('reaction-button');
  const resultEl = document.getElementById('result');
  const historyEl = document.getElementById('history');
  const pdfBtn = document.getElementById('download-pdf');
  const sessionCtrl = document.getElementById('session-ctrl');
  const progressBar = document.getElementById('progress');
  const dailyTableBody = document.querySelector('#daily-table tbody');
  const dailySection = document.getElementById('daily-section');

  // Kamera + einmaliges Session-GPS
  const Evidence = (() => {
    let stream = null, videoEl, canvasEl, ctx;
    let lastGeo = { lat: null, lng: null, acc: null, ts: null };

    async function init() {
      videoEl = document.getElementById('frontcam');
      canvasEl = document.getElementById('shot');
      ctx = canvasEl.getContext('2d');
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
        videoEl.srcObject = stream;
      } catch { stream = null; }
      try { await captureLocation(); } catch {}
    }
    function has() { return !!stream && !!videoEl && !!ctx; }
    function captureLocation() {
      return new Promise((resolve, reject) => {
        if (!("geolocation" in navigator)) return reject();
        navigator.geolocation.getCurrentPosition(
          pos => {
            const { latitude, longitude, accuracy } = pos.coords;
            lastGeo = { lat: latitude, lng: longitude, acc: accuracy, ts: new Date().toISOString() };
            resolve(lastGeo);
          },
          err => reject(err),
          { enableHighAccuracy: true, timeout: 8000 }
        );
      });
    }
    async function getSessionLocation() {
      return {
        link: (lastGeo.lat ? `https://maps.google.com/?q=${lastGeo.lat},${lastGeo.lng}` : null),
        meta: lastGeo
      };
    }
    async function snap({ maxWidth = 640, quality = 0.85 } = {}) {
      if (!has() || videoEl.videoWidth === 0) return { dataUrl: null, ts: new Date().toISOString(), w: 0, h: 0 };
      const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
      const scale = Math.min(1, maxWidth / vw);
      const w = Math.round(vw * scale), h = Math.round(vh * scale);
      canvasEl.width = w; canvasEl.height = h;
      ctx.drawImage(videoEl, 0, 0, w, h);
      return { dataUrl: canvasEl.toDataURL("image/jpeg", quality), ts: new Date().toISOString(), w, h };
    }
    return { init, getSessionLocation, snap };
  })();

  // State
  let state = 'idle', startTime = 0, holding = false;
  let scheduled = null, trialToken = 0, readyAt = 0;
  const history = []; let sessionHits = 0; const MAX_HITS = 10;

  // Session
  let sessionId = null, sessionStartedAt = null, sessionFinishedAt = null, sessionLocation = null;

  // Persistenz
  const LS_KEY = 'rt_trials_v1';
  const loadTrials = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch { return []; } };
  function saveTrial(t) {
    const arr = loadTrials();
    arr.unshift(t);
    if (arr.length > 1000) arr.pop();
    localStorage.setItem(LS_KEY, JSON.stringify(arr));
  }

  // UI
  const setRed = () => { btn.classList.add('red'); btn.classList.remove('green'); btn.textContent = 'Warten…'; };
  const setGreen = () => { btn.classList.remove('red'); btn.classList.add('green'); btn.textContent = 'KLICK!'; };
  const setProgress = n => { progressBar.style.width = (Math.max(0, Math.min(10, n)) / 10 * 100) + '%'; };

  function renderHistory() {
    historyEl.innerHTML = '';
    history.slice(0, 10).forEach(it => {
      const li = document.createElement('li');
      const left = document.createElement('span');
      const right = document.createElement('span');
      left.textContent = it.ts;
      if (it.type === 'early') { li.className = 'early'; right.textContent = 'zu früh'; }
      else { right.textContent = `${it.ms} ms`; }
      li.append(left, right);
      historyEl.appendChild(li);
    });
  }

  function updateDailyTable() {
    const t = loadTrials(), map = new Map();
    for (const x of t) {
      if (typeof x.ms !== 'number') continue;
      const k = x.date || (x.tsISO ? (new Date(x.tsISO)).toISOString().slice(0, 10) : null);
      if (!k) continue;
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(x.ms);
    }
    const rows = Array.from(map.entries()).sort((a, b) => (a[0] < b[0] ? 1 : -1));
    dailyTableBody.innerHTML = '';
    for (const [d, list] of rows) {
      const best = Math.min(...list);
      const last10 = list.slice(0, 10);
      const avg = Math.round(last10.reduce((s, x) => s + x, 0) / last10.length);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${d}</td><td>${best}</td><td>${avg}</td>`;
      dailyTableBody.appendChild(tr);
    }
    dailySection.style.display = rows.length ? 'block' : 'none';
  }

  function pushEarly(msg = 'Zu früh!') {
    history.unshift({ ts: new Date().toLocaleString('de-DE'), type: 'early' });
    if (history.length > 10) history.pop();
    renderHistory();
    resultEl.textContent = msg;
    vibrateShort();
  }

  // Zwei-Phasen-Speicherung
  async function pushHit(rawMs) {
    const adj = Math.max(0, Math.round(rawMs - getOffset()));
    const now = new Date();

    if (!sessionId) {
      sessionId = 's_' + Math.random().toString(36).slice(2, 10);
      sessionStartedAt = now.toISOString();
      try { await Evidence.init(); } catch {}
      try { sessionLocation = await Evidence.getSessionLocation(); } catch { sessionLocation = null; }
    }

    // Phase A: sofort sichern (ohne Evidence)
    const trialId = now.toISOString();
    const baseTrial = {
      tsISO: trialId,
      date: ymd(now),
      ms: adj,
      sessionId,
      evidence: {}
    };
    saveTrial(baseTrial);

    // UI sofort
    history.unshift({ ts: now.toLocaleString('de-DE'), type: 'hit', ms: adj });
    if (history.length > 10) history.pop();
    renderHistory();
    resultEl.innerHTML = `Reaktionszeit: <strong>${adj} ms</strong>`;
    vibrateShort();

    sessionHits++;
    setProgress(sessionHits);
    if (sessionHits >= MAX_HITS) finishSession(); else startTest();

    updateDailyTable(); // direkt nach Phase A

    // Phase B: Evidence async anhängen
    queueMicrotask(async () => {
      const pic = await Evidence.snap({ maxWidth: 640, quality: 0.8 });
      const loc = sessionLocation || (await Evidence.getSessionLocation().catch(() => null)) || null;

      const arr = loadTrials();
      const i = arr.findIndex(t => t.tsISO === trialId);
      if (i >= 0) {
        const t0 = arr[i];
        t0.evidence.location = loc ? {
          lat: loc.meta?.lat ?? null,
          lng: loc.meta?.lng ?? null,
          acc: loc.meta?.acc ?? null,
          ts:  loc.meta?.ts  ?? null,
          link: loc.link || null
        } : null;
        t0.evidence.selfie = {
          ts: pic?.ts || null,
          w:  pic?.w  || null,
          h:  pic?.h  || null,
          dataUrl: pic?.dataUrl || null
        };
        localStorage.setItem(LS_KEY, JSON.stringify(arr));
        updateDailyTable(); // Refresh nach Phase B
      }
    });
  }

  // Timing
  function armTimer(tok) {
    clearTimeout(scheduled);
    const n = performance.now();
    const toGo = Math.max(0, readyAt - n);
    if (document.hidden || state !== 'waiting') return;
    scheduled = setTimeout(() => {
      if (tok !== trialToken || state !== 'waiting') return;
      const n2 = performance.now();
      if (n2 < readyAt) { armTimer(tok); return; }
      requestAnimationFrame(() => {
        if (tok !== trialToken || state !== 'waiting') return;
        state = 'ready';
        setGreen();
        startTime = performance.now();
        if (holding) {
          pushEarly('Zu früh (gedrückt gehalten).');
          startTest();
        }
      });
    }, toGo);
  }

  function startTest() {
    if (state === 'finished') return;
    clearTimeout(scheduled);
    trialToken++;
    state = 'waiting';
    setRed();
    const delay = 2000 + Math.random() * 3000;
    readyAt = performance.now() + delay;
    armTimer(trialToken);
  }

  function finishSession() {
    clearTimeout(scheduled);
    state = 'finished';
    setRed();
    btn.style.display = 'none';
    sessionFinishedAt = new Date().toISOString();
    sessionCtrl.textContent = 'Test wiederholen';
    sessionCtrl.style.display = 'inline-block';
    pdfBtn.style.display = 'inline-block';
    resultEl.textContent = 'Test abgeschlossen.';
    updateDailyTable();
  }

  async function startSession() {
    try { await Evidence.init(); } catch {}
    sessionId = 's_' + Math.random().toString(36).slice(2, 10);
    sessionStartedAt = new Date().toISOString();
    sessionFinishedAt = null;
    try { sessionLocation = await Evidence.getSessionLocation(); } catch { sessionLocation = null; }

    history.length = 0;
    renderHistory();
    resultEl.textContent = '';
    btn.style.display = 'block';
    sessionCtrl.style.display = 'none';
    pdfBtn.style.display = 'none';
    sessionHits = 0;
    setProgress(0);
    state = 'idle';
    holding = false;
    startTest();
    updateDailyTable();
  }

  // Events
  btn.addEventListener('pointerdown', async () => {
    if (state === 'finished') return;
    holding = true;
    if (state === 'waiting') {
      pushEarly();
      startTest();
    } else if (state === 'ready') {
      await pushHit(performance.now() - startTime);
    }
  }, { passive: true });

  ['pointerup','pointercancel','pointerleave'].forEach(ev => {
    btn.addEventListener(ev, () => { holding = false; }, { passive: true });
  });

  sessionCtrl.addEventListener('click', startSession);

  document.addEventListener('visibilitychange', () => {
    clearTimeout(scheduled);
    if (document.hidden) {
      if (state === 'waiting' || state === 'ready') {
        state = 'idle';
        setRed();
        resultEl.textContent = 'Pausiert (Tab nicht sichtbar).';
      }
    } else {
      if (state !== 'finished' && sessionCtrl.style.display === 'none') {
        state = 'waiting';
        setRed();
        // readyAt wird neu gesetzt, um Fairness zu wahren
        const delay = 2000 + Math.random() * 3000;
        readyAt = performance.now() + delay;
        armTimer(trialToken);
      }
    }
  });

  // PDF mit Selfie + blau/unterstrichenem „(Ort)“
  pdfBtn.addEventListener('click', () => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });

    const LEFT = 20, RIGHT = 190, LINE = 6;
    const IMG_W = 28, IMG_H = 21, GAP = 2;
    let y = 18;

    doc.setFontSize(16);
    doc.setTextColor(0,0,0);
    doc.text('Reaktionstest Ergebnisse', LEFT, y); y += 8;

    doc.setFontSize(11);
    if (sessionId) {
      doc.text(`Session: ${sessionId}`, LEFT, y); y += LINE;
      if (sessionStartedAt) { doc.text(`Start:   ${new Date(sessionStartedAt).toLocaleString('de-DE')}`, LEFT, y); y += LINE; }
      if (sessionFinishedAt) { doc.text(`Ende:    ${new Date(sessionFinishedAt).toLocaleString('de-DE')}`, LEFT, y); y += LINE; }
      y += 2;
    }

    doc.setFontSize(12);
    doc.text('Letzte 10 Tests:', LEFT, y); y += LINE;

    const all = loadTrials();
    const recent = all.slice(0, 10);
    doc.setFontSize(11);

    recent.forEach((t, i) => {
      const needY = LINE + (t?.evidence?.location?.link ? LINE : 0)
                   + (t?.evidence?.selfie?.dataUrl ? (IMG_H + GAP) : 0) + 2;
      if (y + needY > 285) { doc.addPage(); y = 15; }

      const ts = new Date(t.tsISO || Date.now()).toLocaleString('de-DE');
      const msText = (typeof t.ms === 'number') ? `${t.ms} ms` : '—';
      doc.setTextColor(0,0,0);
      doc.text(`${i+1}. ${ts} – ${msText}`, LEFT, y);
      y += LINE;

      const link = t?.evidence?.location?.link;
      if (link) {
        const linkText = '(Ort)';
        const x = LEFT + 6;
        const yLink = y;

        doc.setTextColor(0, 102, 204);
        doc.textWithLink(linkText, x, yLink, { url: link });
        const w = doc.getTextWidth(linkText);
        doc.setDrawColor(0, 102, 204);
        doc.line(x, yLink + 0.6, x + w, yLink + 0.6);
        doc.setTextColor(0,0,0);
        y += LINE;
      }

      const imgData = t?.evidence?.selfie?.dataUrl;
      if (imgData) {
        const xImg = RIGHT - IMG_W;
        doc.addImage(imgData, 'JPEG', xImg, y, IMG_W, IMG_H);
        doc.setFontSize(9);
        doc.text('Selfie', xImg, y + IMG_H + 4);
        doc.setFontSize(11);
        y += IMG_H + GAP;
      }

      y += 2;
    });

    if (y > 270) { doc.addPage(); y = 15; }

    doc.setFontSize(12);
    doc.setTextColor(0,0,0);
    doc.text('Tagesübersicht:', LEFT, y); y += LINE; doc.setFontSize(11);

    const byDate = new Map();
    for (const t of all) {
      if (typeof t.ms !== 'number') continue;
      const k = t.date || (t.tsISO ? (new Date(t.tsISO)).toISOString().slice(0,10) : null);
      if (!k) continue;
      (byDate.get(k) || byDate.set(k, []).get(k)).push(t.ms);
    }
    const rows = Array.from(byDate.entries()).sort((a,b)=>(a[0] < b[0] ? 1 : -1)).slice(0, 20);
    rows.forEach(([date, list]) => {
      const best = Math.min(...list);
      const avg10 = Math.round(list.slice(0,10).reduce((s,x)=>s+x,0)/Math.min(10, list.length));
      if (y + LINE > 290) { doc.addPage(); y = 15; }
      doc.text(`${date}: Best ${best} ms | Ø10 ${avg10} ms`, LEFT, y);
      y += LINE;
    });

    doc.save('Reaktionstest-Ergebnisse.pdf');
  });

  // Init
  updateDailyTable(); // zeigt Tabelle, falls Daten vorhanden
  // Start per Button
})();
</script>
</body>
</html>